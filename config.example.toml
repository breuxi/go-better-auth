# GoBetterAuth Configuration Example
# This file demonstrates all available configuration options for GoBetterAuth.
# Copy this file to config.toml and modify the values as needed.

# Application Name
app_name = "GoBetterAuth"

# Base URL for the application (used as the base url of the API and for redirects, emails, etc.)
base_url = "http://localhost:8080"

# Base Path for API endpoints (e.g., "/auth")
base_path = "/auth"

# SECURITY NOTE: It is recommended to set the 'secret' via the 
# GO_BETTER_AUTH_SECRET environment variable rather than hardcoding it here.
# However if you want, generate using `openssl rand -base64 50 | tr -dc 'A-Za-z0-9' | cut -c -40`
secret = ""

# -----------------------------------
# - Database Configuration
# -----------------------------------

[database]
provider = "sqlite"
# SECURITY NOTE: It is recommended to set the 'connection_string' via the 
# GO_BETTER_AUTH_DATABASE_URL environment variable rather than hardcoding it here.
url = "auth.db"
max_open_conns = 25
max_idle_conns = 5
conn_max_lifetime = "10m"

# -----------------------------------
# - Logger Configuration
# -----------------------------------

[logger]
level = "debug"  # Options: "debug", "info", "warn", "error"


# -----------------------------------
# - Session Configuration
# -----------------------------------

[session]
cookie_name = "gobetterauth.session_token"
expires_in = "30m"
update_age = "5m"
cookie_max_age = "24h"
secure = false
http_only = true
same_site = "lax"  # Options: "lax", "strict", "none"

# -----------------------------------
# - Security Configuration
# -----------------------------------

[security]
trusted_origins = []
[security.cors]
allow_credentials = true
allowed_origins = ["*"] # If using session plugin, specify exact origins instead of "*"
allowed_methods = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]
# If using the CSRF plugin, ensure the CSRF token header is included here
allowed_headers = ["Authorization", "Content-Type", "Cookie", "Set-Cookie"]
exposed_headers = []
max_age = "24h"
# IMPORTANT CORS NOTE: If using the session plugin, the CORS plugin must specify exact allowed_origins.
# Setting allowed_origins = ["*"] with allow_credentials = true is NOT allowed by browsers and will fail.
# Example CORS configuration when using sessions:
# allow_credentials = true
# allowed_origins = ["https://yourdomain.com", "https://api.yourdomain.com"]

# -----------------------------------
# - Event Bus Configuration
# -----------------------------------
# The event bus handles internal authentication events and allows plugins to communicate
# Supports multiple providers via Watermill.
# Provider options: "gochannel", "sqlite", "postgres", "redis", "kafka", "nats", "rabbitmq"

[event_bus]
# Optional prefix for all event topics (default: "")
prefix = ""
# Maximum concurrent handlers for event processing (default: 100)
max_concurrent_handlers = 100

# GoChannel Configuration (Default - In-Memory)
# Best for development and testing - events lost on restart
# Other providers enable distributed event handling across multiple instances
provider = "gochannel"
[event_bus.go_channel]
buffer_size = 100

# SQLite Configuration
# Event storage in SQLite file (good for single-instance deployments with persistence)
# provider = "sqlite"
# [event_bus.sqlite]
# db_path = "events.db"  # File path for the SQLite database (relative to current working directory)

# Redis Configuration
# Enables distributed event handling across multiple instances
# provider = "redis"
# [event_bus.redis]
# Prefer to use EVENT_BUS_REDIS_URL environment variable to set the URL
# url = "redis://localhost:6379/0"
# consumer_group = "gobetterauth_consumer_group"

# Kafka Configuration
# For high-throughput, distributed event streaming
# provider = "kafka"
# [event_bus.kafka]
# brokers = "localhost:9092"
# consumer_group = "gobetterauth_consumer_group"

# NATS Configuration
# Lightweight, cloud-native messaging
# provider = "nats"
# [event_bus.nats]
# url = "nats://localhost:4222"

# AMQP Configuration (RabbitMQ)
# Traditional message broker with advanced routing
# provider = "rabbitmq"
# [event_bus.rabbitmq]
# Prefer to use EVENT_BUS_RABBITMQ_URL environment variable to set the URL
# url = "amqp://guest:guest@localhost:5672/"

# -----------------------------------
# - Plugins Configuration
# -----------------------------------

[plugins]

# --- Config Manager Plugin (allows runtime configuration changes via the Admin API) ---

[plugins.config_manager]
enabled = true

# --- Secondary Storage Plugin (provides secondary storage backends for other plugins) ---

[plugins.secondary_storage]
enabled = true
provider = "memory" # Options: "memory", "database", "redis"

[plugins.secondary_storage.memory]
cleanup_interval = "1m"

# [plugins.secondary_storage.database]
# cleanup_interval = "1m"

# [plugins.secondary_storage.redis]
# SECURITY NOTE: It is recommended to set the 'url' via the
# REDIS_URL environment variable rather than hardcoding it here.
# url = ""
# max_retries = 3
# pool_size = 10
# pool_timeout = "30s"

# --- Email Plugin (handles email sending via SMTP or Resend) ---

[plugins.email]
enabled = true
provider = "smtp"  # Options: "smtp", "resend"
# Can also be set via FROM_ADDRESS environment variable
from_address = ""

# Optional: Fallback provider if primary fails
# fallback_provider = "resend"

# Resend API Configuration (when provider = "resend")
# NOTE: The Resend API key MUST be set via the RESEND_API_KEY environment variable.

# --- CSRF Plugin (for protecting against CSRF attacks) ---

[plugins.csrf]
enabled = true
cookie_name = "gobetterauth_csrf_token"
header_name = "X-GOBETTERAUTH-CSRF-TOKEN"
max_age = "24h"
secure = false
same_site = "lax"  # Options: "lax", "strict", "none" (Note: HttpOnly=false and Secure=true are hardcoded for Double-Submit Cookie pattern)
# Go 1.25+ Header-based CSRF Protection (Recommended)
# When enabled, validates cross-origin requests using Sec-Fetch-Site and Origin/Host headers.
# This provides defense-in-depth alongside token validation.
# Disabled by default for specific clients (mobile apps, CLI tools, webhooks).
enable_header_protection = false

# --- Email/Password Plugin ---

[plugins.email_password]
enabled = true
min_password_length = 8
max_password_length = 128
disable_sign_up = false
require_email_verification = true
auto_sign_in = true
send_email_on_sign_up = true
send_email_on_sign_in = false
email_verification_expires_in = "24h"
password_reset_expires_in = "1h"
request_email_change_expires_in = "1h"

# --- OAuth2 Plugin (for social logins) ---

# [plugins.oauth2]
# enabled = true

# SECURITY NOTE: It is recommended to set the 'client_secret' for each of these via their 
# respective environment variables as shown in the .env.example file rather than hardcoding it here.
# [plugins.oauth2.providers.discord]
# enabled = true
# client_id = "your-client-id"
# client_secret = "your-client-secret"
# redirect_url = "http://localhost:8080/auth/oauth2/callback/discord"
# scopes = ["email", "identify"]

# [plugins.oauth2.providers.github]
# enabled = true
# client_id = "your-client-id"
# client_secret = "your-client-secret"
# redirect_url = "http://localhost:8080/auth/oauth2/callback/github"
# scopes = ["user:email"]

# [plugins.oauth2.providers.google]
# enabled = true
# client_id = "your-client-id"
# client_secret = "your-client-secret"
# redirect_url = "http://localhost:8080/auth/oauth2/callback/google"
# scopes = ["openid", "email", "profile"]

# Example: Additional fields for a custom OAuth2 provider
# auth_url = "https://provider.com/oauth2/authorize"
# token_url = "https://provider.com/oauth2/token"
# user_info_url = "https://provider.com/oauth2/userinfo"
# user_id_field = "sub"
# email_field = "email"
# name_field = "name"
# picture_field = "picture"

# Example: Generic OAuth2 Provider Configuration
# You can add any custom OAuth2 provider by specifying a new section under [plugins.oauth2.providers.<provider_name>]
# Replace <provider_name> with your desired provider key (e.g., "mycustom")
# The following is a template for a generic OAuth2 provider:
#
# [plugins.oauth2.providers.mycustom]
# enabled = true
# client_id = "your-client-id"
# client_secret = "your-client-secret"
# redirect_url = "http://localhost:8080/auth/oauth2/callback/mycustom"
# auth_url = "https://provider.com/oauth2/authorize"
# token_url = "https://provider.com/oauth2/token"
# user_info_url = "https://provider.com/oauth2/userinfo"
# scopes = ["profile", "email"]
# # Optional: Custom field mappings if your provider returns non-standard fields
# user_id_field = "sub"
# email_field = "email_address"
# name_field = "full_name"
# picture_field = "avatar_url"

# --- Session Plugin (use for SSR apps) ---

# Cookie-based session authentication that stores session tokens as HTTP-only cookies
# Note: Client IP address and User-Agent are automatically captured from the request and
# stored in the session record for security audit trails and session management features.
[plugins.session]
enabled = true

# --- JWT Plugin (use for SPAs and mobile apps) ---

# [plugins.jwt]
# enabled = true
# algorithm = "eddsa"
# key_rotation_interval = "720h"
# expires_in = "15m"
# refresh_expires_in = "168h"
# jwks_cache_ttl = "5m"
# refresh_grace_period = "1m"

# --- Bearer Plugin (use for SPAs and mobile apps) ---

# [plugins.bearer]
# enabled = true
# header_name = "Authorization"

# --- Rate Limit Plugin (to prevent abuse and brute-force attacks) ---

# [plugins.ratelimit]
# enabled = true
# window = "1m"
# max = 100
# prefix = "ratelimit:"
# provider = "memory" # Options: "memory", "redis", "database"
# [plugins.ratelimit.custom_rules]
# "/path/to/your/endpoint" = { disabled = false, window = "1m", max = 5, prefix = "" }
#
# Optional: Configure cleanup intervals for storage providers
# [plugins.ratelimit.memory]
# cleanup_interval = "1m"  # How often to remove expired entries (default: 1m)
# 
# [plugins.ratelimit.database]
# cleanup_interval = "1m"  # How often to remove expired entries from database (default: 1m)

# -----------------------------------
# - Route-to-Plugin Mappings (Standalone Mode)
# -----------------------------------
# Declaratively map routes to plugins for hook execution.
# In standalone mode, all plugin-to-route associations are defined here via [[route_mappings]] tables.
# This enables full plugin routing control without code changes.
# Plugin IDs follow the format "{plugin_name}.{operation}" (e.g., "session.auth", "csrf.protect")

# Example routes:
# [[route_mappings]]
# path = "/me"
# method = "GET"
# plugins = ["session.auth"] (SSR) or ["bearer.auth"] (SPA/mobile)

# [[route_mappings]]
# path = "/sign-in"
# method = "POST"

# [[route_mappings]]
# path = "/sign-up"
# method = "POST"

# [[route_mappings]]
# path = "/change-password"
# method = "POST"
# plugins = ["session.auth", "csrf.protect"]

# [[route_mappings]]
# path = "/sign-out"
# method = "POST"
# plugins = ["session.auth", "csrf.protect"]
